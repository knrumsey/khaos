% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adaptive_khaos2.R
\name{adaptive_khaos2}
\alias{adaptive_khaos2}
\title{Experimental g-prior: Bayesian Adaptive Polynomial Chaos Expansion}
\usage{
adaptive_khaos2(
  X,
  y,
  degree = 15,
  order = 5,
  nmcmc = 10000,
  nburn = 9000,
  thin = 1,
  max_basis = 1000,
  a_g = 0.001,
  b_g = 1000,
  zeta = 1,
  g2_sample = "mh",
  g2_init = NULL,
  s2_lower = 0,
  a_sigma = 0,
  b_sigma = 0,
  a_M = 4,
  b_M = 4/length(y),
  move_probs = rep(1/3, 3),
  coin_pars = list(function(j) 1/j, 1, 2, 3),
  degree_penalty = 0,
  legacy = TRUE,
  verbose = TRUE
)
}
\arguments{
\item{X}{A data frame or matrix of predictors scaled to be between 0 and 1}

\item{y}{a response vector}

\item{degree}{Maximum polynomial degree for each basis function.}

\item{order}{Maximum order of interaction for each basis function.}

\item{nmcmc}{Number of MCMC iterations.}

\item{nburn}{Number of initial MCMC iterations to discard.}

\item{thin}{Keep every \code{thin} samples.}

\item{max_basis}{Maximum number of basis functions.}

\item{a_g, b_g}{Prior parameters for global g-prior term (on precision scale)}

\item{zeta}{Hyperparameter for modified g-prior. Setting zeta = 0 reduces to the usual g-prior.}

\item{g2_sample}{Character string specifying the method used to sample or update the prior scaling parameter \code{g0^2}.}

\item{g2_init}{Initial calue of g2 (global precision for g-prior). Becomes the only value when \code{g2_sample = "fixed"}.}

\item{s2_lower}{Lower bound on process variance (numerically useful for deterministic functions).}

\item{a_sigma, b_sigma}{Shape/scale parameters for the IG prior on process variance (default is Jefffrey's prior)}

\item{a_M, b_M}{Shape/scale parameters for the Gamma prior on expected number of basis functions.}

\item{move_probs}{A 3-vector with probabilities for (i) birth, (ii) death, and (iii) mutation.}

\item{coin_pars}{A list of control parameters for coinflip proposal}

\item{degree_penalty}{Increasing this value encourages lower order polynomial terms (0 is no penalization).}

\item{legacy}{Logical. If TRUE, mimics original implementation behavior (from the emulator comparison paper),
which may retain invalid basis function structures across iterations. Defaults to FALSE.}

\item{verbose}{Logical. Should progress information be printed?}
}
\description{
The emulation approach of Francom et al. (2020) for BMARS, modified for polynomial chaos.
}
\details{
Implements the RJMCMC algorithm described by Francom & Sanso (2020) for BMARS, modifying it for polynomial chaos basis functions.
As an alternative the NKD procedure of Nott et al. (2005), we use a coinflipping procedure to identify useful variables. See writeup (coming soon) for details.
The coin_pars argument is an ordered list with elements:
\enumerate{
\item{a function giving proposal probability for q_0, the expected order of interaction,}
\item{epsilon, the base weight for each variable (epsilon=Inf corresponds to uniform sampling),}
\item{alpha, the exponent-learning rate,}
\item{num_passes a numerical parameter only.}
}

Sampling method for g0^2 depends on \code{g2_sample}
\describe{
\item{\code{"f"}}{Fixed: Do not update \code{g0^2}; carry forward the previous value (\code{g2[i] <- g2[i-1]}).}
\item{\code{"lf"}}{Laplace-Full: Use a Laplace approximation to sample \code{g0^2} under the full marginal likelihood (no orthogonality assumption).}
\item{\code{"lo"}}{Laplace-Orthogonal: Use a Laplace approximation to sample \code{g0^2} assuming the orthogonality approximation applies.}
\item{\code{"mh"}}{Metropolis-Hastings with full Laplace approximation as proposal. Target is the full posterior density of \code{g0^2}.}
\item{\code{"mho"}}{Metropolis-Hastings with orthogonal Laplace approximation as proposal. Target is the full posterior density of \code{g0^2}. under the orthogonality assumption.}
\item{\code{"mhoo"}}{Metropolis-Hastings with orthogonal Laplace approximation as proposal. Target is the posterior density of \code{g0^2} under the orthogonality assumption.}
}

Other proposal notes:
Expected order q0 is chosen from 1:order with weights \code{coin_pars[[1]](1:order)}
Degree is chosen from q0:degree with weights \code{(1:(degree-q0+1))^(-degree_penalty)} and a random partition is created (see helper function).

Two types of change steps are possible (and equally likely)
A re-ordering of the degrees
A single variable is swapped out with another one (only used when \code{ncol(X) > 3})
}
\examples{
X <- lhs::maximinLHS(100, 2)
f <- function(x) 10.391*((x[1]-0.4)*(x[2]-0.6) + 0.36)
y <- apply(X, 1, f) + stats::rnorm(100, 0, 0.1)
fit <- adaptive_khaos(X, y)
}
\references{
Francom, Devin, and Bruno SansÃ³. "BASS: An R package for fitting and performing sensitivity analysis of Bayesian adaptive spline surfaces." Journal of Statistical Software 94.LA-UR-20-23587 (2020).

Nott, David J., Anthony YC Kuk, and Hiep Duc. "Efficient sampling schemes for Bayesian MARS models with many predictors." Statistics and Computing 15 (2005): 93-101.
}
